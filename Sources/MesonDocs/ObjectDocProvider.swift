class ObjectDocProvider: DocProvider {
  func addToDict(dict: inout [String: String]) {
    dict["both_libs.get_shared_lib"] = "Returns the stored shared library"
    dict["both_libs.get_static_lib"] = "Returns the stored static library"
    dict["build_tgt.extract_all_objects"] =
      "Acts the same as `extract_objects`, but returns all object files generated by this target."
    dict["build_tgt.extract_objects"] =
      "Returns an opaque value representing the object files generated for those source files. This is typically used to take single object files and link them to unit tests or to compile some source files with custom flags"
    dict["build_tgt.found"] =
      "Always returns true. This function is meant to make executables objects feature compatible with `external_program` objects. This simplifies use-cases where an executable is used instead of an `external_program`."
    dict["build_tgt.full_path"] =
      "Returns a full path pointing to the result target file. NOTE: In most cases using the object itself will do the same job as this and will also allow Meson to setup inter-target dependencies correctly. Please file a bug if that doesn't work for you."
    dict["build_tgt.name"] = "Returns the name of the target."
    dict["build_tgt.path"] = "Returns a full path pointing to the result target file."
    dict["build_tgt.private_dir_include"] =
      "Returns a value that works like `include_directories()`, but points to the private directory of this target. Usually only needed if an another target needs to access some generated internal headers of this target."
    dict["cfg_data.get"] =
      "Returns the value of varname, if the value has not been set returns default_value if it is defined (since 0.38.0) and errors out if not"
    dict["cfg_data.get_unquoted"] =
      "Returns the value of varname but without surrounding double quotes (\"). If the value has not been set returns default_value if it is defined and errors out if not."
    dict["cfg_data.has"] = "Returns true if the specified variable is set"
    dict["cfg_data.keys"] = "Returns an array of keys of the configuration data object."
    dict["cfg_data.merge_from"] =
      "Takes as argument a different configuration data object and copies all entries from that object to the current."
    dict["cfg_data.set"] = "Sets a variable to a given value"
    dict["cfg_data.set10"] =
      "Is the same as `cfg_data.set()` but the value is either true or false and will be written as 1 or 0, respectively"
    dict["cfg_data.set_quoted"] =
      "Is same as `cfg_data.set()` but quotes the value in double quotes (\")"
    dict["compiler.alignment"] = "Returns the alignment of the specified type."
    dict["compiler.check_header"] =
      "Returns true if the specified header is usable with the specified prefix, dependencies, and arguments."
    dict["compiler.cmd_array"] = "Returns an array containing the command(s) for the compiler."
    dict["compiler.compiles"] = "Returns true if the code compiles."
    dict["compiler.compute_int"] = "Computes the value of the given expression"
    dict["compiler.find_library"] =
      "Tries to find the library specified in the positional argument."
    dict["compiler.first_supported_argument"] =
      "Given a list of strings, returns a single-element list containing the first argument that passes the `compiler.has_argument()` test or an empty array if none pass."
    dict["compiler.first_supported_link_argument"] =
      "Given a list of strings, returns the first argument that passes the `compiler.has_link_argument()` test or an empty array if none pass."
    dict["compiler.get_argument_syntax"] =
      "Returns a string identifying the type of arguments the compiler takes."
    dict["compiler.get_define"] =
      "Returns the given preprocessor symbol's value as a string or empty string if it is not defined."
    dict["compiler.get_id"] = "Returns a string identifying the compiler."
    dict["compiler.get_linker_id"] = "Returns a string identifying the linker."
    dict["compiler.get_supported_arguments"] =
      "Returns an array containing only the arguments supported by the compiler, as if `compiler.has_argument()` were called on them individually."
    dict["compiler.get_supported_function_attributes"] =
      "Returns an array containing any names that are supported GCC style attributes. Equivalent to `compiler.has_function_attribute()` was called on each of them individually."
    dict["compiler.get_supported_link_arguments"] =
      "Returns an array containing only the arguments supported by the compiler, as if `compiler.has_link_argument()` were called on them individually."
    dict["compiler.has_argument"] =
      "Returns true if the compiler accepts the specified command line argument, that is, can compile code without erroring out or printing a warning about an unknown flag."
    dict["compiler.has_function"] =
      "Returns true if the given function is provided by the standard library or a library passed in with the args keyword."
    dict["compiler.has_function_attribute"] =
      "Returns true if the compiler supports the GNU style (`__attribute__(...)`) `name`."
    dict["compiler.has_header"] =
      "Returns true if the specified header exists with the specified prefix, dependencies, and arguments."
    dict["compiler.has_header_symbol"] =
      "Detects whether a particular symbol is declared in the specified header."
    dict["compiler.has_link_argument"] =
      "Returns true if the linker accepts the specified command line argument, that is, can compile and link code without erroring out or printing a warning about an unknown flag. Link arguments will be passed to the compiler, so should usually have the `-Wl,` prefix. On VisualStudio a `/link` argument will be prepended."
    dict["compiler.has_member"] = "Returns true if the type has the specified member."
    dict["compiler.has_members"] = "Returns true if the type has *all* the specified members."
    dict["compiler.has_multi_arguments"] =
      "The same as `compiler.has_argument()` but takes multiple arguments and uses them all in a single compiler invocation."
    dict["compiler.has_multi_link_arguments"] =
      "The same as `compiler.has_link_argument()` but takes multiple arguments and uses them all in a single compiler invocation."
    dict["compiler.has_type"] = "Returns true if the specified token is a type."
    dict["compiler.links"] = "Returns true if the code compiles and links."
    dict["compiler.preprocess"] = "Preprocess a list of source files but do not compile them"
    dict["compiler.run"] = "Attempts to compile and execute the given code fragment."
    dict["compiler.sizeof"] = "Returns the size of a given type or -1 is the type is unknown"
    dict["compiler.symbols_have_underscore_prefix"] =
      "Returns true if the C symbol mangling is one underscore (`_`) prefixed to the symbol."
    dict["compiler.version"] = "Returns the compiler's version number as a string."
    dict["custom_idx.full_path"] =
      "Returns a full path pointing to the result target file NOTE: In most cases using the object itself will do the same job as this and will also allow Meson to setup inter-target dependencies correctly. Please file a bug if that doesn't work for you."
    dict["custom_tgt.full_path"] =
      "Returns a full path pointing to the result target file NOTE: In most cases using the object itself will do the same job as this and will also allow Meson to setup inter-target dependencies correctly."
    dict["custom_tgt.to_list"] =
      "Returns a list of opaque objects that references this target, and can be used as a source in other targets."
    dict["dep.as_link_whole"] =
      "Returns a copy of the dependency object with all link_with arguments changed to link_whole."
    dict["dep.as_system"] =
      "Returns a copy of the dependency object, which has changed the value of `include_type` to `value`."
    dict["dep.found"] = "Returns whether the dependency was found."
    dict["dep.get_configtool_variable"] =
      "Gets the command line argument from the config tool, or, if invoked on a non config-tool dependency, error out."
    dict["dep.get_pkgconfig_variable"] =
      "Gets the pkg-config variable specified, or, if invoked on a non pkg-config dependency, error out."
    dict["dep.get_variable"] =
      "A generic variable getter method, which replaces the `get_*type*_variable` methods. This allows one to get the variable from a dependency without knowing specifically how that dependency was found. If `default_value` is set and the value cannot be gotten from the object then `default_value` is returned, if it is not set then an error is raised."
    dict["dep.include_type"] = "Returns the value set by the `include_type` kwarg."
    dict["dep.name"] = "Returns the name of the dependency that was searched."
    dict["dep.partial_dependency"] =
      "Returns a new dependency object with the same name, version, found status, type name, and methods as the object that called it. This new object will only inherit other attributes from its parent as controlled by keyword arguments."
    dict["dep.type_name"] =
      "Returns a string describing the type of the dependency, the most common values are `internal` for deps created with `declare_dependency()` and `pkgconfig` for system dependencies obtained with Pkg-config."
    dict["dep.version"] = "The version number as a string."
    dict["disabler.found"] = "Always returns false"
    dict["env.append"] = "Appends the given values to the old value of the environment variable."
    dict["env.prepend"] =
      "Same as `env.append()` except that it writes to the beginning of the variable."
    dict["env.set"] =
      "Sets the environment variable specified in the first argument to the values in the varargs joined by the separator."
    dict["external_program.found"] = "Returns whether the executable was found."
    dict["external_program.full_path"] = "Returns a string pointing to the script or executable."
    dict["external_program.path"] = "Returns a string pointing to the script or executable."
    dict["external_pogram.version"] = "The version number as a string."
    dict["feature.allowed"] = "Returns whether the feature was set to 'enabled' or 'auto'"
    dict["feature.auto"] = "Returns whether the feature was set to 'auto'"
    dict["feature.disable_auto_if"] =
      "Returns the feature, with 'auto' converted to 'disabled' if `value` is true."
    dict["feature.disabled"] = "Returns whether the feature was set to 'disabled'"
    dict["feature.enabled"] = "Returns whether the feature was set to 'enabled'"
    dict["feature.require"] =
      "Returns the object itself if the value is true; an error if the object is 'enabled' and the value is false; a disabled feature if the object is 'auto' or 'disabled' and the value is false."
    dict["generator.process"] =
      "Takes a list of files, causes them to be processed and returns an object containing the result which can then, for example, be passed into a build target definition."
    dict["module.found"] = "Returns true if the module was successfully imported, otherwise false."
    dict["runresult.compiled"] =
      "If true, the compilation succeeded, if false it did not and the other methods return unspecified data. This is only available for `compiler.run()` results."
    dict["runresult.returncode"] = "The return code of executing the compiled binary"
    dict["runresult.stderr"] = "The standard error produced when the command was run."
    dict["runresult.stdout"] = "The standard out produced when the command was run."
    dict["subproject.found"] = "Returns whether the subproject was successfully setup."
    dict["subproject.get_variable"] = "Fetches the specified variable from inside the subproject."
  }
}
